---

title: Pobieranie nazwy hosta z dhcp.
date: '2009-08-26T19:58:00.000+02:00'
author: kaarol
tags:
- C / C++
- Oprogramowanie klienckie
modified_time: '2015-02-23T23:51:45.297+01:00'
blogger_id: tag:blogger.com,1999:blog-1272990746006552071.post-4620414911073566815
---

<p>Jakiś tydzień temu zabrałem się za kończenie nowych obrazów dla komputerów na salach laboratoryjnych. Poza drobnymi zmianami (dystrybucja lekkich aplikacji via SCCM) chciałem zminimalizować czas jaki poświęcałem na zmianę nazw komputerów po klonowaniu. Kilka lat temu przyjęliśmy, że komputery na salach będą się nazywać KompXXX-YY. Gdzie XXX to numer sali a YY to komputer na miejscu YY licząc od prawej strony sali. W systemach Linux rozwiązanie było proste :) Dorzuciliśmy opcję 12 do DHCP i systemy pobierały sobie odpowiednią nazwę z serwera DHCP. W przypadku Windows sprawa się komplikuje i dobrze by było nazwy zmienić na samym początku by nie robić sobie bałaganu. Nazwę można pobrać czy wygenerować na kilka sposobów:</p>  <ul>   <li>pobranie nazwy z DNS – wszystko fajnie, tylko jak nazwy nie mam w DNS bo pojawi się po dodaniu Windowsa do domeny </li>    <li>wykorzystanie Sysprepa do generowania nazwy Komp400-XX – Muszę mieć kilka plików unattend do Sysprepa :/ </li>    <li>przeparsowanie otrzymanego Adresu IP i wygenerowanie nazwy komputera.&#160; - Czasem od naszej reguły nazewnictwa zdarzają się wyjątki:) </li>    <li>pobranie nazwy z DHCP – idealne rozwiązanie. </li> </ul>  <p>&#160;</p>  <p>Skoro miałem wszystkie nazwy w DHCP to teraz wystarczyło pobrać odpowiednią opcje i zamienić nazwę stanowiska:) Jak sie okazało otrzymanie nazwy komputera z DHCP i wrzucenie jej do jakieś zmiennej nie jest takie proste. Jedyne dostępne API dla Windowsowego klienta DHCP jest napisane w C++:/&#160; Opcje z DHCP pobieramy za pomocą funkcji <a href="http://msdn.microsoft.com/en-us/library/aa363298%28VS.85%29.aspx">DHCPRequestParams</a>, która przyjmuje na wejściu kilka parametrów. Między innymi wymagane jest podanie nazwy interfejsu sieciowego. TUTAJ UWAGA nazwa interfejsu jest rozumiana jako identyfikator urządzenia a nie jako np. “Połączenie lokalne”. Identyfikator również możemy sobie wyciągnąć za pomocą API do interfejsów sieciowych.&#160; Przyznam się, że stworzenie działającej aplikacji, która pobiera identyfikator pierwszego interfejsu a następnie wyciąga z DHCP odpowiednią nazwę zepsuł mi trochę krwi. Najpierw musiałem sobie przypomnieć pewne podstawy Visual C++, potem musiałem załapać, że w nazwie interfejsu mam podać identyfikator. Następnie musiałem rozgryźć jak dynamicznie wyszukać ten identyfikator. Koniec końców udało mi się napisać mały programik w VC++, który pobiera odpowiednią opcje z DHCP i za pomocą newsida zmienia nazwę i SID. Poniżej kod, który pobiera id pierwszego interfejsu i następnie wyciąga z DHCP nazwę stacji.&#160; Przypominam iż z zawodu nie jestem programistą i na samym początku dążę do tego by kod działał wedle moich oczekiwaniami. Następnie jak mam czas to staram się go upiększać. W kodzie częściowo starałem się wykorzystać przykłady dostępne na stronach MSDN. </p>  <pre lang="C++">#include &lt; winsock2.h&gt;<br/>#include &lt; iphlpapi.h &gt;<br/>#include &lt; stdio.h &gt;<br/>#include &lt; stdlib.h &gt;<br/>#include &lt; windows.h &gt;<br/>#include &lt; dhcpcsdk.h &gt;<br/>#include &lt; string &gt;<br/>#include &lt; wchar.h &gt;<br/>#pragma comment( lib, &quot;dhcpcsvc.lib&quot; )<br/>#pragma comment(lib, &quot;IPHLPAPI.lib&quot;)<br/>#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))<br/>#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))<br/><br/>int __cdecl main()<br/>{<br/>	CONST int iAdapterIDLenght= 260;<br/>	CONST int iHostnameLenght=60;<br/>	int dw;<br/>	CHAR pszHostNameBuf[iHostnameLenght];<br/>	DWORD dwError, dwSize;<br/>	CHAR TmpBuffer[iHostnameLenght]; <br/>	WCHAR wcAdapterName[iAdapterIDLenght];<br/>    PIP_ADAPTER_INFO pAdapterInfo;<br/>    PIP_ADAPTER_INFO pAdapter = NULL;<br/>    DWORD dwRetVal = 0;<br/>	ULONG ulOutBufLen = sizeof (IP_ADAPTER_INFO);<br/><br/>    pAdapterInfo = (IP_ADAPTER_INFO *) MALLOC(sizeof (IP_ADAPTER_INFO));<br/>    if (pAdapterInfo == NULL) <br/>	{<br/>        printf(&quot;Error allocating memory needed to call GetAdaptersinfo\n&quot;);<br/>        return 1;<br/>    }<br/>    if (GetAdaptersInfo(pAdapterInfo, &amp;ulOutBufLen) == ERROR_BUFFER_OVERFLOW) <br/>	{<br/>        FREE(pAdapterInfo);<br/>        pAdapterInfo = (IP_ADAPTER_INFO *) MALLOC(ulOutBufLen);<br/>        if (pAdapterInfo == NULL) <br/>		{<br/>            printf(&quot;Error allocating memory needed to call GetAdaptersinfo\n&quot;);<br/>            return 1;<br/>        }<br/>    }<br/><br/>    if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &amp;ulOutBufLen)) == NO_ERROR)<br/>	{<br/>        pAdapter = pAdapterInfo;<br/>		dw = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAdapter-&gt;AdapterName, -1, wcAdapterName, 0);<br/>		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pAdapter-&gt;AdapterName, -1, wcAdapterName, dw);<br/><br/>		DHCPCAPI_PARAMS DhcpApiHostNameParams = {<br/>				0,                // Flags<br/>				OPTION_HOST_NAME, // OptionId<br/>				FALSE,            // vendor specific?<br/>				NULL,             // data filled in on return<br/>				0                 // nBytes<br/>			}; <br/>		DHCPCAPI_PARAMS_ARRAY RequestParams = {<br/>            1,  // only one option to request <br/>            &amp;DhcpApiHostNameParams<br/>        };<br/><br/>		DHCPCAPI_PARAMS_ARRAY SendParams = {0,NULL};<br/><br/>		dwSize = sizeof(TmpBuffer);<br/>		dwError = DhcpRequestParams(<br/>            DHCPCAPI_REQUEST_SYNCHRONOUS, // Flags<br/>            NULL,                         // Reserved<br/>            wcAdapterName,					// Adapter Name<br/>            NULL,                         // not using class id<br/>	           SendParams,		          // sent parameters<br/>            RequestParams,                // requesting params<br/>            (PBYTE) TmpBuffer,            // buffer<br/>            &amp;dwSize,                      // buffer size<br/>            NULL                          // Request ID<br/>        );<br/><br/>		if( ERROR_MORE_DATA == dwError ) <br/>		{<br/>			printf(&quot;Error: %s&quot;,dwError);<br/>		}<br/><br/>		if( NO_ERROR == dwError ) <br/>		{<br/><br/>            if( DhcpApiHostNameParams.nBytesData ) <br/>            {<br/><br/>                CopyMemory(pszHostNameBuf, DhcpApiHostNameParams.Data,DhcpApiHostNameParams.nBytesData);<br/>                pszHostNameBuf[DhcpApiHostNameParams.nBytesData] = '\0';<br/>				printf(&quot;(12) DHCP Host Name: %s\n&quot;,pszHostNameBuf);<br/>                return 0;<br/>            }<br/>		}<br/>		else<br/>		{<br/>			printf(&quot;Error: %u&quot;,dwError);<br/>		}<br/><br/>	} <br/>	else <br/>	{<br/>        printf(&quot;GetAdaptersInfo failed with error: %d\n&quot;, dwRetVal);<br/><br/>    }<br/>    if (pAdapterInfo)<br/>        FREE(pAdapterInfo);<br/>	getchar();<br/>    return 0;<br/>} </pre><br/><br/><p>W wolnej chwili postaram się napisać małą bibliotekę do podpięcia pod C#, tak bym mógł pobrać dowolne opcje z DHCP. </p>